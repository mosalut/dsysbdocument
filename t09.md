# deploy

_deploy_ is a task deployment. Tasks in _DSYSB_ are similar to smart contracts in Ethereum. _DSYSB_ defines a set of [task instructions](dsysbinstruction.md).

A task mainly consists of instructions and a data space. Instructions operate on the data space, modifying its data. When a task is issued, these instructions are not executed, but the task is checked for syntax errors, such as insufficient parameters following an instruction number. This is similar to compile-time errors in other languages.

Tasks, like assets, have a lifespan, and their lifespan's meaning and mechanisms of existence are the same.

## 字段
- _instructs_: A byte array containing one or more instructions, little-endian.
- _vData_: A byte array that represents the initial values the space used for instruction operations, in little-endian order.
- _price_: Unit price of asset life.
- _block_: How many blocks to survive.
- _from_: Publisher's wallet address
- _hier_: Heir's wallet address.
- _nonce_: Preventing replay attacks.
- _bytePrice_: Byte price.
- _signer_: Signature.


The total length of the _deploy_ command must not exceed 65536 characters, because other fields occupy fixed space. Therefore, the length of _instructs_ + _vData_ must not exceed 65353 characters.

The instruction number for each instruction occupies one byte. If the following parameters point to an index in _vdata_ (similar to a memory address), they occupy two bytes. Since the maximum number of bytes will not exceed 65353, and two bytes can manage 65536 bytes of data, this is sufficient.

The following is a complete _deploy_ transaction command:

```bash
$ ./dsysbcmd create deploy '{"instructs":[0,5,0,6,0,3,0],"vData":[0,1,2,3,4,5,6,7,8,9,100],"from":"DCUz2Z2D8C9YC7ZWaVBwAx16vygpAG4fST","price":1,"blocks":10000,"bytePrice":1}'
```

After waiting for two or more blocks, you can then view the tasks using the _gettasks_ and _gettask_ commands, just like you would view assets.

The task has a _remain_ field, which indicates how many block the lifespan is left.

[0,5,0,6,0,3,0] Note that this is decimal notation; each byte can be 0-255.

The first 0 represents the instruction number, which corresponds to the instruction name _ins\_movsb_, and its function is to copy its own array.

The following 5,0 is the position of the source _vdata_. Due to little-endian order, it should be regarded as 05, which is vData[5].

The 6,0 that follows is the position of the target _vdata_. Due to little-endian order, it should be interpreted as 06, which is vData[6].

The 3 and 0 at the end represent the length to be copied from the target location. Due to little-endian order, this should be interpreted as 03, meaning 3 bytes will be copied.

Therefore, if this command is invoked, it will copy 5, 6, 7 from vData to the location where 6, 7, 8 are located.

The final content of vData will be [0,1,2,3,4,5,5,6,7,9,100].

This example only contains one instruction. If you need multiple instructions, please continue writing the instructions after the last 3,0 of _instructions_.

Typically, a meaningful task will include instructions for reading call parameters and transferring funds.

If you don't want to write byte sequence directly, you can learn about the _asm_ command, which calls a __dasm__ source code file and then compiles it into _instructs_ and _vData_, returning raw-data directly.

For all specific instructions, please refer to the [Task Instruction Set](dsysbinstruction.md), which mainly describes the deployment principles.
